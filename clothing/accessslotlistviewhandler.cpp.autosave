#include "accessslotlistviewhandler.h"

#include <QMenu>
#include <QStandardItemModel>

AccessSlotListViewHandler::AccessSlotListViewHandler(QListView *list, QMap<QString, QList<ClothingMod::BlockedParts>> &data, QStringList &slot_list) : view(list), data_map(&data), available_slots(&slot_list)
{
    // Setup view
    view->setContextMenuPolicy(Qt::CustomContextMenu);

    // Create menu object
    menu = new QMenu();

    // Connections
    QObject::connect(list, &QListView::doubleClicked, [this] (const QModelIndex &index) {emit(edit_triggered(index.data().toString()));});
}

AccessSlotListViewHandler::~AccessSlotListViewHandler()
{
    // The list, map data, and string list data pointers are handled by other more qualified sources. Don't touch them here.

    delete menu;
}

void AccessSlotListViewHandler::update()
{
    // This function updates the list from the data. Called when the data is changed elsewhere or on initial load.

    // Start with a fresh model.
    if (view->model() != nullptr)
        delete view->model();

    // Setup model
    auto *model = new QStandardItemModel(view);

    // Populate model
    for (const QString &key : data_map->keys()) {
        model->appendRow(new QStandardItem(key));
    }

    // Add model to view
    view->setModel(model);
}

void AccessSlotListViewHandler::contex_menu(const QPoint &pos)
{
    // Displays the context menu.

    // Empty the menu.
    menu->clear();

    // Obtain item index using a dark ritual.
    QModelIndex index = view->indexAt(pos);

    // If a valid index is selected, add 'remove', 'edit', and 'change slot' actions
    if (index.isValid()) {
        // Remove action
        QAction *rem_action = menu->addAction("Remove entry");
        QObject::connect(rem_action, &QAction::triggered, [this, index] () {remove_item(index);});

        // Edit action
        QAction *edit_action = menu->addAction("Edit");
        QObject::connect(edit_action, &QAction::triggered, [this, index] () {emit(edit_triggered(index.data().toString()));});

        // Change slot action
        QMenu *change_menu = menu->addMenu("Change slot...");
        for (const QString &slot : *available_slots) {
            QAction *change_action = change_menu->addAction(slot);
            QObject::connect(change_action, &QAction::triggered, [this, change_action, index] () {change_slot(index, change_action->text());});
        }
    }

    // Add submenu and populate it with options
    QMenu *add_menu = menu->addMenu("Add entry...");
    for (const QString &slot : *available_slots) {
        QAction *slot_action = add_menu->addAction(slot);
        QObject::connect(slot_action, &QAction::triggered, [this, slot_action] () {add_item(slot_action->text());});
    }

    // Show menu
    menu->popup(view->viewport()->mapToGlobal(pos));
}

void AccessSlotListViewHandler::remove_item(const QModelIndex &index)
{
    // Remove data at index

    if (!index.isValid())
        return;

    data_map->remove(index.data().toString()); // From data map
    view->model()->removeRow(index.row()); // From model
}

void AccessSlotListViewHandler::add_item(const QString &slot)
{
    // Simply construct a new item and add it to the model and data map

    data_map->insert(slot, QList<ClothingMod::BlockedParts>()); // To data map
    qobject_cast<QStandardItemModel*>(view->model())->appendRow(new QStandardItem(slot)); // To model
}

void AccessSlotListViewHandler::change_slot(const QModelIndex &index, const QString &slot)
{
    // Change an entrys associated slot

    // First, copy data and remove old entry
    QList<ClothingMod::BlockedParts> data = data_map->take(index.data().toString());

    // Second, add under new key
    data_map->insert(slot, data);

    // Finally, update model
    qobject_cast<QStandardItemModel*>(view->model())->itemFromIndex(index)->setData(slot);
}
